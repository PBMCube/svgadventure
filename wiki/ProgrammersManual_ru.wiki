#summary Шаги по изготовлению собственного квеста на svgAdventure

= Делаем собственный квест на базе svgAdventure =

== Изображение героя ==

В каталоге engine/ располагается файл hero.png, содержащий кадры мультипликации для изображения главного героя. По умолчанию он содержит буквенно-цифровые обозначения, соответствующие направлению и фазе мультипликации (буква --- направление, цифра --- фаза):

|| *Обозначение* || *Направление* ||
|| W || "Запад" (влево по экрану) ||
|| S || "Юг" (вниз по экрану) ||
|| E || "Восток" (вправо по экрану) ||
|| N || "Север" (вверх по экрану) ||
|| O || На месте ||

Для изменения изображения героя нарисуйте в этом файле вместо буквенно-цифровых обозначений своего героя в соответствующих позах.

== Фоновые ресунки локаций ==

В каталоге engine/ находятся файлы с именами вида `sceneXXX.png`, где _XXX_ --- номер локации. Замените эти рисунки на свои файлы с аналогичным разрешением.

== Логика локаций ==

Логика прописывается в файлах с именами вида `sceneXXX.js`, где _XXX_ --- номер соответствующей локации (надо бы реализовать это более изящно, если это возможно).

=== Расположение стен ===

Расположение стен хранится в массиве landscape. В каждом файле `sceneXXX.js` есть присваивание примерно такого вида:
{{{
    landscape =
        [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
         [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];
}}}

Расположение элементов игрового поля здесь такое же, как на экране; единицы соответствуют стенам, нули --- пустому месту.

=== Создание дверей ===

Для создания дверей, ведущих из локации в локацию, надо записать в файл инициализации сцены (`sceneXXX.js`, где _XXX_ --- номер сцены) строку примерно такого вида:
{{{
createDoor(0, 0, 'scene002', 0, 6, 'sc001_door01.png');
}}}

Здесь 0, 0 (первые два числа) --- координаты самой двери, 'scene002' --- имя файла с локацией, в которую ведёт дверь, 0, 6 (вторая пара чисел) --- точка, в которой герой окажется на новой локации после прохождения через дверь, а 'sc001_door01.png' --- имя графического файла с изображением этой конкретной двери (разумеется, никто не мешает вам в вашей игре для всех дверей использовать одно и то же изображение).

=== Создание объектов ===

Для создания объектов надо записать в файл инициализации сцены (`sceneXXX.js`, где _XXX_ --- номер сцены) строку примерно такого вида:

{{{
createObject(5, 5, 20, 20, 'sc001_obj01.png', 'Crystal Rock');
}}}

Здесь 5,5 (первые два числа) --- координаты объекта, 20, 20 (вторая пара чисел) --- размер его изображения, 'sc001_obj01.png' --- файл с изображением объекта, а 'Crystal Rock' --- его название (оно будет отображаться в подсказке, которую увидит пользователь).

Во избежание странных и трудноотлавливаемых глюков, не рекомендуется создавать два и более предметов с одинаковыми названиями.

Помимо этого вызова функции, для создания объекта вам, естественно, понадобится собственно файл с изображением.

Если вы хотите задать реакцию объекта на какие-то действия пользователя, вам необходим номер, под которым объект хранится в массиве objects. Этот номер возвращает функция createObjects, таким образом, код, добавляющий объект, должен быть таким:
{{{
var n = createObject(5, 5, 20, 20, 'sc001_obj01.png', 'Crystal Rock');
}}}
Для отработки ситуаций, когда локация посещается повторно, и скрипт пытается создать уже добавленный и удалённый объект, стоит проверять значение возвращаемой функцией `createObject` переменной: если оно равно -1, править свойства объекта не стоит.

В настоящий момент можно задать носимость объекта и реакцию неносимого объекта на команду "Use" (использовать), а также реакцию на применение другого объекта.

==== Делаем объект носимым ====

Для того, чтобы объект стал носимым (т.е. пользователь мог добавить его в свой инвентарь), нужно сделать его свойство 'portable' равным 'true', вот так:
{{{
    var n = createObject(10, 5, 20, 20, 'sc002_obj01.png', 'Crystal Rock');
    if (n != -1) {
        objects[n]['portable'] = true;
    }
}}}

По умолчанию все объекты _не_ являются носимыми.

==== Определяем, как использовать объект ====

Для того, чтобы задать реакцию объекта на попытку его использовать, применяется механизм обратного вызова (callback). При создании скрипта инициализации той или иной сцены вы должны определить функцию, которая будет выполнена при использовании объекта, и поместить её в массив objects, в описание нужного объекта. Если мы определили функцию, скажем, useObject1(), как-нибудь так:
{{{
function useObject1() {
    alert('You was used this rock');
}
}}}
то задать эту функцию как реакцию на попытку использовать объект можно следующим образом:
{{{
// Создаём объект...
var n = createObject(5, 5, 20, 20, 'sc001_obj01.png', 'Crystal Rock');
// ...и задаём функцию для его использования
objects[n]['use'] = useObject1;
}}}

==== Определяем, как реагировать на применение объекта к другим объектам ====

Для применения к объекту других объектов (хранимых главным героем в инвентаре) также используется механизм обратного вызова (callback). В скрипте инициализации должна быть определена функция, принимающая в качестве параметра имя применяемого к объекту другого объекта; в зависимости от имени возможна разная реакция.

Если мы задали функцию, определяющую реакцию на применение другого объекта, вот так:
{{{
function applyObjectToObject1(someObject) {
    alert(someObject + ' applied');
}
}}}
то код, задающий эту функцию как вызываемую при применении к данному объекту другого, будет выглядеть так:
{{{
// Создаём объект... 
var n = createObject(10, 5, 20, 20, 'sc002_obj01.png', 'Crystal Rock');
// ...и определяем, как он будет реагировать на применение к себе другого объекта
if (n != -1) {
    objects[n]['apply'] = applyObjectToObject1;
}
}}}

=== Диалоги ===

==== Создание самого говорящего объекта ====

Прежде всего, для того, чтобы с объектом можно было разговаривать, надо сделать его свойство `talking` равным `true`. Это делается примерно так:
{{{
    n = createObject(9, 5, 40, 54, 'mushroom.png', 'Talking Mushroom');
    if (n != -1) {
        objects[n]['talking'] = true;
        ...
}}}

Здесь `n` --- номер свежесозданного объекта в массиве `objects`; проверка на равенство -1 нужна для обработки случая повторного посещения той же локации (подробно это описано в начале раздела "Создание объектов").

Затем необходимо назначить говорящему объекту сценарий диалога (описание создания сценария диалога см. ниже). Это делается так:
{{{
        ...
        objects[n]['dialog'] = dialogTreeMushroom;
        ...
}}}

Здесь `dialogTreeMushroom` --- массив со сценарием диалога, `n` --- номер объекта в массиве `objects`, который вернула функция `createObject()`.

==== Создание сценария диалога ====

Сценарий диалога представляет собой массив объектов (ассоциативных массивов), каждый из которых описывает некоторое состояние диалога главного героя и объекта. У состояния есть следующие свойства:
 * `start` --- реплика, которую говорит объект (NPC); в начальном состоянии эта реплика часто бывает пустой --- игрок должен иметь возможность выбирать, с какой реплики начать диалог;
 * `answers` --- список вариантов ответов, один из которых должен выбрать игрок.

Список, лежащий в `answers`, содержит несколько объектов (ассоциативных массивов), описывающих различные варианты продолжения разговора. Каждый из этих объектов содержит следующие поля:
 * `variant` --- реплика главного героя;
 * `func` --- функция, которая будет выполнена, если игрок выберет именно эту реплику; для продолжения разговора следует указать функцию `goPhrase()` (о передаче ей аргументов см. ниже); анонимные функции, определяемые прямо на месте, естественно, допустимы --- см. пример;
 * `arg` --- аргумент, передаваемый функции, обозначенной в `func`; если эта функция не принимает аргументов, укажите `null`; если функция --- `goPhrase()` (то есть выбранное действие это продолжение диалога), то аргументом должен быть номер состояния диалога (индекс этого состояния в массиве, хранящем диалог).

Чтобы закончить диалог по инициативе объекта, достаточно в качестве реакции на очередную реплику указать функцию `clearPhraseVariants()` с аргументом `null`.

Вот пример:

{{{
    dialogTreeMushroom = [];
    dialogTreeMushroom.push(
        {'start': '',
         'answers':
             [{'variant': 'Hello',
               'func': goPhrase,
               'arg': 1},
              {'variant': 'All your base are belong to us!',
               'func': goPhrase,
               'arg': 2}
             ]
        }
    );
    dialogTreeMushroom.push(
        {'start': 'Hello. I\'m a mushroom',
         'answers':
             [{'variant': 'I like mushrooms!',
               'func': clearPhraseVariants,
               'arg': null},
              {'variant': 'Bye',
               'func': clearPhraseVariants,
               'arg': null}
             ]
        }
    );
    dialogTreeMushroom.push(
        {'start': 'GTFO',
         'answers':
             [{'variant': 'Shut up',
               'func': clearPhraseVariants,
               'arg': null},
              {'variant': 'Show me the alert',
               'func': function(t) {alert(t); clearPhraseVariants()},
               'arg': 'Here it is'}
             ]
        }
    );
}}}

Здесь описывается создание диалога, которых хранится в массиве `dialogTreeMushroom`. Пользователю предлагается начать диалог с одной из двух реплик: "Hello" или "All your base are belong to us!". В ответ на "Hello" объект отвечает "Hello. I'm a mushroom", и пользователю предоставляются на выбор две ответные реплики: "I like mushrooms!" и "Bye". После каждой из них NPC заканчивает диалог. В ответ на "All your base are belong to us!" объект отвечает "GTFO", и у пользователя появляется два варианта ответа: "Shut up" и "Show me the alert". Реакция на "Shut up" --- простое окончание диалога; в ответ на "Show me the alert" выводится диалоговое окно с текстом "Here it is", а затем диалог, опять же, завершается.

Обратите внимание, каким образом выполнение нескольких команд в качестве реакции на реплику обеспечено с помощью анонимной функции.

=== Изменение вида кнопок, переключающих режимы ===

Кнопки описаны в файле `modecontrol.svg`. Если вы хотите изменить их вид, отредактируйте этот файл. Важно следить за тем, чтобы каждый элемент, описывающий кнопку, имел id, содержащий название действия, которое вызывает кнопка ("walk", "get", "use" или "talk"), иначе кнопки не будут работать. В качестве примера можно воспользоваться существующим файлом `modecontrol.svg`.

[Main_ru Назад на главную страницу русского раздела]